###c++重启计划

#####函数
######参数传递
* 安值调用：
	按值调用传递参数的方式简称**传值**，有时又称为**按拷贝调用（call by copy）**.如果以传值方式调用一个函数，则实际参数的值传递给形式参数时，形式参数得到的是是实际参数的另一个备份。在函数中改变形式参数的值时，改变的只是这个备份中的值，而实际参数的值并不受到影响。如果想在被调用函数中改变实际参数的值，就应该使用按引用调用的参数传递方式。
* 按引用调用
	**引用类型**是在其他数据类型后加上一个类型修饰符“&”，该数据类型被称为**引用的基类型**。注意在C++中 '&'既可以作为类型修饰符，也可以作为一元运算符（取操作数的地址）或二元运算符（两个操作数进行位与运算）。可以与指针类型中"*"比较。
	引用类型的变量并不是真正的创建一个新的对象，而是作为一个对象的别名。例如以下语句声明了一个整数类型的变量i以及与之相关的引用类型变量ir；
    ```shell
    int i = 1;   //真正创建了一个整数类型的对象并初始化为1
    int& ir = i; //引用类型的变量必须初始化，指明ir是i的别名
    ```
    引入ir作为i的别名后，对ir的运算就相当于作用在变量i上。如：
    ```shell
    ir = 8;
    cout<<&ir<<" "<<ir<<endl ;  //相当于输出i的地址     
    ```
    C++引入引用类型的主要作用是提供按引用调用的参数传递方式。需要注意的是：引用类型还有另一种用法————将函数的返回类型定义为引用类型时，函数调用表达式可以作为左值使用：
    ```C
    p 8.4.5
    ```
* 缺省参数
  对形式参数可以指定任意的初始化表达式作为缺省值，具有缺省值的形式参数称为**缺省参数。当程序有多个形式参数时，缺省参数必须从右向左定义，并且在一个缺省参数的右边不能还有未指定缺省值的参数。**例如：
  ```shell
  int func(int i=8,char c,int j=45);
  ```
  中的缺省参数定义是不合法的，因为在缺省参数i的右边有未指定的缺省值的参数c。
  定义函数的缺省参数时，既可以在函数的原型中给出，也可以在函数的定义中给出，但必须是在任何以缺省参数方式调用该函数之前，而且在同一编译模块中不允许重复给出缺省参数。
  这种做法为某一些应用提供了方便。如果需要多次调用一个函数，并且要多次给这个函数传递同样的参数时，应考虑使用缺省参数。
* 局部变量与全局变量
	1. 局部变量：在函数内（块作用域中）声明的变量称为局部变量。
	2. 全局变量： 在文件作用域中的声明的变量称为全局变量，全局变量在函数定义之外声明，不属于任何函数，从被定义开始，在整个文件范围内都有效，可以被不同函数共同使用。当程序开始执行时，全部的全局变量都被创建，在整个程序运行期间都存在.
	3. 总结：全局变量增加了函数之间的联系，降低了函数的独立性，导致函数不容易理解且难以重复使用。它出错的隐蔽性很深，给程序的调试造成了很大的困难。较好的解决方法是**程序中的每一个变量对于必须访问它的函数来说是局部的**
	4. 函数之间的通信方式： 目前已经学习了函数的两种通信方式：一种是参数传递和返回值，另一种是全局变量。显然参数传值与返回值是比全局变量更为安全的一种方式。如果选用了全局变量，则应该认真考虑是否应该是否可以使用参数传递与返回值来代替。
	
* 变量的存储类别
	C++语言的变量可以选择四种存储类别： 自动的，寄存器的，静态的和外部的，分别用保留字：auto ，register，static和extern表示。变量的存储类别在变量的声明时同时进行说明：
一般形式为：
```shell
	存储类型关键字 类型 变量名列表；
```
例如：
```shell
auto int i;
static char c;
```
auto和register只能修饰局部变量，而static和extern既可以修饰局部变量也可以修饰全局变量。如果在变量声明中未指定存储类别，则局部变量缺省存储类别为auto，全局变量缺省存储类别为extern。
  1. 自动变量（auto）被分配到动态存储区中。
  2. register用于指示编译程序在可能的情况下，将这个变量放在寄存器中使用，以提高访问与修改变量的时间效率。如：
```shell
for (register int i = 0; i < 1000; i++ ) count<<i;
```
效率高的原理： 数据在被处理之前，先从内存读取到寄存器中，进行所需要的运算，然后将结果放回内存中，寄存器的存取速度远快于内存，所以指定一个变量为寄存器存储类别可以避免数据在内存与寄存器之间反复传递，以提高程序的执行速度。但是由于可用的寄存器个数有限，当程序员定义的寄存器变量书目超过了限制时，编译程序将自动的把寄存器变量转换为自动变量。因为当前的C++编译器具备代码优化能力，可以自动的判断哪些变量可以尽量长时间的保存在寄存器中，以优化程序的执行速度，所以较少使用寄存器变量。
  3. 静态变量
  静态变量既可以是局部变量也可以是全局变量。但是无论哪一种情况，静态变量都具有全局寿命，其寿命从程序启动开始到程序的结束。注意：生存器和作用域是不同的，尽管静态变量具有全局生存期，但是在其作用域之外是不可以访问的。 
  如果静态变量在初始化时没有指定初始值，那么其初始值缺省为0，静态全局变量初始化在程序执行main（）函数之前开始执行，静态局部变量初始化在程序运行中第一次经过它的声明是开始执行，但是无论那种情况，初始化工作只作作一次。
  4. 外部变量
  声明外部变量时，可以进行初始化。也可以不初始化。带有初始化表达式的声明语句称为定义性声明，未带有初始化表达式的声明语句称为引用性声明。如果一个全局变量在声明时没有指定储存类型，则缺省存储类别为外部的，并且该声明是定义性声明，如果这是未指定初始化表达式，则默认缺省值为0，如：
  ```shell
  extern int age = 30;         //定义性声明
  extern char choice;          //引用性声明
  ```
  作为定义性声明出现的extern变量必须是全局变量，而引用性声明出现的extern变量既可以是全局变量也可以是局部变量。
  定义性声明指示编译程序为该外部变量分配内存，而引用性声明告诉编译程序该名字的变量在程序其他地方已经给出了定义性声明，这里只是引用其名字而不给其分配内存，在一个程序中，一个变量必须有且仅有一次定义性声明，当可以又多次引用性声明，定义性声明和引用性声明可以出现在一个文件作用域中，外部变量有全局性声明，且它的初始化工作是在程序执行main（）函数之前就已经完成。
  为防止编写程序时犯错，可以在一个文件中声明的全乎变量前加上static修饰，被声明为静态的全局变量其作用域仅限于该文件内，而不可由其他文件用extern引用。这样仅有一个文件共享的全局变量就可以得到保护，并可由程序员独立的命名，不会与其他模块中的全局变量产生名字冲突
  保留字static同样可以修饰一个函数名字，其作用是使得该函数仅可由相同文件模块中的其他函数调用，而其他文件模块中的函数则无法访问该函数。这是传统C语言程序员常用的模块组织技术。
    

######预处理命令
在将"C\++"源代码转换为可执行代码的过程中，处理源代码的第一个工具是预处理程序，然后才将预处理结果传递给编译程序进行编译。预处理程序只关注预处理命令，而葫芦俄大多数的程序语句，不做修改的传送给编译程序。
	预处理命令以“#”开头并占用一行。如果一行写不完一条命令，可以继续写在下一行，但钱一行的末尾必须以一个特殊的继续符号“\”结束。预处理命令并不是C++语言真正的语句，因此在预处理命令命令末尾不使用“;"作为结束标志。
    
* 文件包含
	文件包含预处理命令 #include 导致了直接的文本替换：预处理程序直接按照命令参数所给的文件名取出完整的文件，并一次文件的内容直接替换各条预处理命令，这样就可以将若干个源文件合并成一个源文件，然后将其作为一个整体来进行编译。
    \#include命令有两种形式：
    （1） \#include <文件名>
    （2） \#include "文件名"
    形式（1）一般用于C\++系统提供的库函数，这些库函数声明的源文件间通常放在系统目录中的include子目录下。形式（2）一般用于程序员自己开发的模块，。C\++编译程序会在当前目录下搜索指定的文件，找不到再到系统目录下搜索。
    如果要使用其它文件中描述的不属于标准库中的函数，这些函数通常有该项目的程序员编写，于是编写\#include命令时，必须用双引号包含的文件名，并可以在文件名中指定该文件所在的目录，例如：
    ```shell
    	#include "c:\work\mydef.h"
    ```
   这条命令指示预处理程序将位于 c:\work\目录下的mydef.h文件的内容复制到此源程序中。
* 宏定义
	```shell
    	#define PI 3.14
    ```
	\#define 称为宏定义预处理命令，也是用于实现文本替换的：它的第一个参数PI（即符号常量名）指出了被替换的文件，称为**宏名**,第二个参数（3.14）指出了用作替换的文本。当预处理程序在后续的源代码中遇到了与第一个参数(宏名)相对应的标识符时，就会用第二个参数替换该符号，这个过程称为**宏展开**
    还可以用#define定义带参数的宏，也就是插入到源代码中的一系列计算。其命名规则格式为：
    ```shell
    	#define 宏名（形式参数表） 字符串
    ```
    字符串定义了一组用宏名标记的操作，其中包含在圆括号中所指定的形式参数（**注意在声明时，宏定义中的形式参数不需要指明数据类型**）
    例如：
    ```shell
    	#include <iostream.h>
        #define max(a,b) ((a>b) a:b)
        main()
        {
        	float x,y;
            cout<<"Please input x and y :";
            cin>>x>>y;           //设置x和y的值
            cout<<"The max is :" <<max(x,y);
        }
    ```
    从逻辑上来说，宏与函数在代码中的使用方式相同，都是用一个单一的名字来代表一组操作，宏的运行速度比函数快。
   
* 条件编译
	条件编译预处理命令控制条件计算，条件编译有多种用法。
	1.第一种：
	```shell
    	#ifdef 标识符
        	程序段1
        #endif
    ```
   当程序作为一个C++程序编译时，当ifdef条件不满足时，预处理程序就会将程序段1隐藏起来使之不为编译程序所见，即不参加编译。注意指定的标识符不一定有值。2.第二种：
   ```shell
   	#ifdef 标识符
    	程序段1
    #else
    	程序段2
    #endif
   ```
   例如：
   ```shell
   	#define MT
    #ifdef MT
    	#define NFILE 40
    #else
    	#define NFILE 20
    #endif
   ``` 
3.第三种情况
	```shell
    	#ifndef 标识符
        	程序段1
        #else
        	程序段2
        #endif
    ```
#####面向对象
######循环计数器
	循环计数器的容量称为模，循环计数器的的计数可以通过C++语言提供的取模运算来完成：
    ```shell
    	a的下一个角度为：
        （a+1） % 360
        a的上一个角度为：
         (a-1 + 360) % 360
         这里必须加上360 ，否则当a为0时，求值的结果为负数
    ```
    如果处理的问题不是从0开始，也可以通过减去最小值转换为这种形式。例如当前月份为m，则m的下一个月是：
    ```shell
    	((m-1) + 1) % 12 +1
    ```
    m的上一个月是：
    ```shell
    	((m-1)-1 + 12) % 12 + 1
    ```
######字符串
字符串实际上是一个特殊的数组，与普通的字符数组的区别在于字符串最后有一个0值字节表示字符串结束。
字符串长度： 字符串的长度为11，但是占用的存储空间为12
**字符串变量**是一个基类型为字符串类型的数组变量，同样遵守先声明后使用的原则。字符串定义的一般形式为：
   char 数组名[元素个数];
   在声明字符串变量时，可用字符串常量进行初始化，如：
   char name[30] = "Zhongshan University";
   注意字符串的长度不要超过其存储空间的大小，因为字符串的结束标识‘\0’超出了为他分配的存储边界，可能破坏其他数据。
   为了必买你上述字符串越界错误，可以不必声明字符数组的长度：
   char name[] = "zhangshan University";
   字符串数组：
   ```shell
   const int max_sub = 24;
   const int max_len = 30;
   char subjects[max_sub][max_len];
   ```
   为了节省存储空间可以使用指针数组：
   ```shell
     const int max_subjects = 24;
     char * subjects[max_subjects];
     //显示第一个字符串和第三个字符串
     cout<< *subjects<<endl;
     cout<< *(subjects + 2);
   ```
   
   字符串操作的库函数：
   同其他类型的数组一样，只可在声明字符串变量时用赋值运算作为初始化，在其他地方不允许直接使用赋值运算：
   char name[30];
   name = "Zhongshan University";     //语法错误
	因为那么实际上是一个常量指针，不可以用复制语句改变其值，即name不允许作为一个“左值”。
    字符串的标准库为：string
    #include <string.h>
    1. 字符串复制：
     stcpy(name,"Zhongshan university");
     字符串的长度：(不计算结束标识 “\0”)
     unsigned int strlen(const char * str);
    2. 字符串复制（将str2指向的字符串复制到str1并返回str1）：
     char * strcpy(char *str1,const char *str1);
     ```shell
     //错误用法
     char * str;
     strcpy(str,"Be careful.")
     //正确用法
     cha *str;
     str = "Be careful."
     //正确用法
     char str[20];
     strcpy(str,"Be careful.");
     ```
    3. 字符串连接
     char * strcat(char * str1 ,const char * str2);
     可能会引起内存的问题，下面是该进的方案：
     ```shell
     	#include <string.h>
        char * sstrcat(char *str1,const char * str2)
        {
        	int m,n = char t,char * str;
            m = strlen(str1);
            n = strlen(str2);
            t = new char[n+1]
            str = new char[m+n+1];
            t = strcpy(t,str2);
            str = strcpy(t,str2);
            str = strcpy(str,t);
            delete str1;          //释放占用的所遇空间
            delete tl
            str1 = str;
            return str1;
        }
     ```
    4. 比较两个字符串是否相同 str1 小于str2 则返回负数
     int strcmp(const char *strl,const char * str2);
    5. 寻找指定字符第一次出现的位置 (如果找到则返回指向该位置的指针，否则返回空指针)：
    	char * strchr(const char *str,in ch);
    6. 寻找指定字符串在字符串中第一次出现的位置(返回值同上)：
    	char * strstr(const char*str1,const char * str2);
        
  字符串转换为整数或者实数：
  C++ 的库stdlib.h提供了这些转换函数
  
    1. 将指针指向的数字字符串转换为整数：
     int atoi(const char * s) ;
    2. 将指针指向的数字字符串转换为实数（double）
     double stof(const char * s);
    3. 转换为长整数
     long atoll(const char * s);
     
    主函数带参数主要有以下两种方式：
    ```shell
    	int main(int argc,char * argv[]);
        int main(int argc,char * argv[],char * env[]);
    ```
    argc是一个整数，代表命令行参数的个数 ，包括命令本身，
    argv[0]:指向命令，argv[1]:第一个参数
    env[]表示环境参数。
######指向对象的指针
######指向函数的指针
######结构类型与枚举类型与类型别名

#####继承机制
######继承与构造函数和析构函数
* 构造函数与析构函数的调用次序
* 向基类构造函数传递实际参数

######集成成员的调整
* 恢复访问控制的方式
* 继承成员的重定义
* 继承成员的重命名
* 屏蔽集成成员

######多重继承
* 多从继承的语法形式
* 多重继承的名字冲突问题
* 多重继承的构造函数和析构函数

#####多态性
######拷贝构造函数
* 函数按值调用传递对象参数产生的问题
* 对象作为函数返回值产生的问题
* 问题的解决拷贝构造函数

######运算符重载
* 运算符函数

######友元函数
* 友元运算符的重载
   **友元**（friend）关系允许类的设计者选择出一族其他的类或函数，使得他们可以访问该类的私有和受保护成员。为什么不直接将友元函数设计为类的成员函数呢？这是因为有时需要在类之外实现函数，例如一个函数需要访问若干个类的私有或受保护数据才可以完成某一个任务，又如与其他程序设计语言（如汇编语言，C语言）等混合编程时，只能编写一个函数而不能用类。在第十章可以看到使用友元函数可以更加自然的使用C++语言的输入\输出类库。
   为了在类定义中对友元加以说明，只需要在保留字friend后列出友元的名字即可。友元可以是一个普通函数（游离在类之外），也可以是一个类的成员函数，甚至是一个完整的类。当某个完整的类被设计成一个友元时，该类中所有的成员函数都被视作友元函数。
   ```C
   //类value中定义了一个友元函数set()，注意set（）不是成员函数
   class VALUE{
   public:
   	friend void set(VALUE obj,int x);  //声明set（）为VALUE的友元
   private:
   	int value;
   };
  //实现友元函数
  void set(VALUE obj,int x) {
  	obj.value = x ; //set() 可以像VALUE成员函数一样访问obj的私有成员
    returnl;
  }

   int main(int argc,char *argv[]) {
   }
   ```
######虚函数
* 定义
* 动态绑定和静态绑定
* 设计合适的绑定方式

######抽象类
* 纯虚函数
* 抽象类
* 纯虚函数与抽象类的应用————多态数据结构

#####类属机制
######类模板
######函数模板

#####出入\输出流
