####Consistent Hash 算法

#####一、场景描述
分布式存储经常会涉及到负载均衡的问题，因为有多个存储介质，分布在不同的节点上，当一个对象被保存的时候，究竟保存在哪个存储介质上，这就是负载均衡问题。

#####二、存在问题

index = hash(object) % N

传统的hash映射存在三个问题：
###### 2.1 
 一个服务器M挂掉了，则所有映射到该服务器的对象都会失效， 怎么办？ 需要将服务器m移除，这是服务器为N+1台，映射公式为
hash(object) % (N-1)。
###### 2.2 
因为访问加重，需要添加服务器，这时服务器的是N+1台， 映射公式变成了：
hash(object) % (N+1)

上面两种情况下，服务器全部都失效了，

###### 2.3
 第三个问题是 因为硬件能力的增强，后加入的节点需要多干一些活，显然上面的hash算法是做不到的。
 
###### (单调性 Monotonicity)另一个衡量指标
点调性是指如果已经有一些内容通过hash被分配到了相应的缓冲中，而又有了新的缓冲加入到系统中。hash的结果应内够保证已分配的内容可以被映射到新的缓存中，而不是会被映射到旧的缓冲集合中的其他缓冲区。

######Consistent Hashing
 Consistent Hashing是一种hash算法， 它能够尽可能小的改变已存在的key映射关系，尽可能的满足单调性的要求
 
* 步骤一  环形Hash 空间
  通常的hash算法都是将Value映射到一个32位的key值，即 0 ～ 2^32-1的空间。可以将其想像成 一个首（0）尾(2^32-1)相接的圆环

* 步骤二 将对象映射到hash空间
考虑4个对象object1 ～ object2 ，通过hash函数计算出hash值key在环上的分布：
 hash(object1) = key1
 hash(object2) = key2
 
* 步骤三 将服务器（cache）映射到hash空间
Consistent hashing 的基本思想是将对象和服务器都映射到一个hash空间，并使用相同的hash算法。
假设当前有A，B和C共3台服务器，那么其映射结果：
hash(serverA) = key A
……
hash(serverC) = key C

* 步骤四 将对象映射到服务器
 现在cache和对象都已经通过一个hash算法映射到 hash 数值空间中了，接下来考虑的是如何将对象映射到cache上面。
 映射规则： 在这个环形空间中，如果沿着顺时针方向从对象的key值出发，直到遇见一个服务器，那么就将对象存储到这个服务器上。因为对象和服务器的hash值是固定的，因此这个服务器必然是唯一确定的。这样就找到了对象和服务器的映射方法。
 
* 步骤五 考察服务器的变动
 前面讲过，通过hash算法余的方法最大的问题在于不满足单调性问题，当服务器有所变动时，服务器会失效，进而对后台服务器造成巨大的冲击。
 1. 移除服务器
 服务器B挂了，根据上面的映射方法，这时受到的影响的只是那些沿 cacheB逆时针遍历直到下一个服务器（服务器C）之间的对象，即本来要映射到服务器B上的那些对象。
 所以这里只需将变动对象 object 4 映射到服务器C上即可。
 2. 添加服务器
 考虑添加一台服务器D的情况，假设在这个环形hash空间中，服务器D被映射到对象object 2 和 object 3 之间，这时受到影响的仅仅是那些 沿 chcheD 逆时针遍历到下一个服务器（服务器B）之间的对象，将这些对象重新映射到服务器D上即可。
 
* 平衡性
 平衡性是指hash的结果可以尽可能的分部到所有的缓冲中，这样可以使所有的缓冲空间得到利用。
 hash算法不能保证绝对的平衡，如果服务器较少，对象并不能保证被均匀的分配到所有的服务器上。
 为了解决上面的问题，Conssitent Hashing 引入了虚拟节点的概念，它可以如下的定义：
 "虚拟节点"（virtual node） 是实际节点在hash空间的复制品（replica），一个实际节点对应若干个"虚拟节点"，这个对应个数也被称之为"复制个数"，"虚拟节点"在hash空间中仍以hash值排列。
 以仅部署 serverA和serverC为例，引入虚拟节点，并设置复制个数为2，则一共会存在4个虚拟节点， serverA1 serverA2 代表A  ， serverB1 和serverB2 代表 B，
 引入虚拟节点后 ，映射关系就从 {对象 -> 节点 }变成了 {对象 -> 虚拟节点 -> 节点}
 
 虚拟节点的hash计算可以采用对应节点的IP地址加数字后缀的发给你是，如 serverA的IP 为：
202.168.14.241  。引入虚拟节点前计算server A 的hash值为：
Hash("202.168.14.241")
引入虚拟节点后 ， 计算虚拟节点服务器A1 和服务器A2的hash值：
hash("202.168.14.241#1");   // cache A1
hash("202.168.14.241#2");   // cache A2
