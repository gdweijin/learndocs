RBM - 详细教程(mytestmy)

#####一、 限制波尔兹曼机

###### 1.1 限制波尔滋曼机的使用方法
一个普通的RBM 网络结构：
![][1]

以上的RBM网络结构有m个可视节点和n个隐藏节点，其中**每个可视节点只和n个隐藏节点相关**，和其他可视节点是独立的，就是这个可视节点的状态只受n个隐藏节点的影响，对于每个隐藏节点也是，只受m个可视节点的影响，这个特点使得RBM的训练变得容易了。


参数：
RBM网络有几个参数，一个是可视层与隐藏层之间的权重矩阵${W_{n \times m}}$，一个是可视节点的偏移量b=(b1,b2⋯bm)，一个是隐藏节点的偏移量c=(c1,c2⋯cn)，这几个参数决定了RBM网络将一个m维的样本编码成一个什么样的n维的样本。


RBM网络的功能有下面的几种，就简单地先描述一下。
首先为了描述容易，先假设每个节点取值都在集合{0,1}中，即$\forall {\rm{i}},{\rm{j}},{v_j} \in \left\{ {0,1} \right\},{h_i} \in \left\{ {0,1} \right\}。$

一个训练样本x过来了取值为x=(x1,x2⋯xm)，根据RBM网络，可以得到这个样本的m维的编码后的样本y=(y1,y2⋯yn)，这n维的编码也可以认为是抽取了n个特征的样本。而这个m维的编码后的样本是按照下面的规则生成的：对于给定的x=(x1,x2⋯xm)，隐藏层的第i个节点的取值为1（编码后的样本的第i个特征的取值为1）的概率为${\rm{p}}\left( {{\rm{hi}} = 1{\rm{|v}}} \right) = {\rm{\sigma }}\left( { \sum \limits_{j = 1}^m wij \times {\rm{vj}} + {\rm{ci}}} \right)，$其中的v取值就是x，hi的取值就是yi，其中${\rm{\sigma }}\left( {\rm{x}} \right) = 1/\left( {1 + {e^{ - x}}} \right)$，是sigmoid函数。也就是说，编码后的样本y的第i个位置的取值为1的概率是p(hi=1|v)。所以，生成yi的过程就是：

i）先利用公式${\rm{p}}\left( {{\rm{hi}} = 1{\rm{|v}}} \right) = {\rm{\sigma }}\left( { \sum \limits_{j = 1}^m wij \times {\rm{vj}} + {\rm{ci}}} \right)$，根据x的值计算概率p(hi=1|v)，其中vj的取值就是xj的值。

ii）然后产生一个0到1之间的随机数，如果它小于p(hi=1|v)，yi的取值就是1，否则就是0（假如p(hi=1|v)=0.6，这里就是因为yi的取值就是1的概率是,0.6，而这个随机数小于0.6的概率也是0.6；如果这个随机数小于0.6，就是这个事件发生了，那就可以认为yi的取值是1这个事件发生了，所以把yi取值为1）。

反过来，现在知道了一个编码后的样本y，想要知道原来的样本x，即解码过程，跟上面也是同理，过程如下：

i）先利用公式${\rm{p}}\left( {{\rm{vj}} = 1{\rm{|h}}} \right) = {\rm{\sigma }}\left( { \sum \limits_{i = 1}^n wij \times {\rm{hi}} + {\rm{bj}}} \right)，$根据y的值计算概率p(vj=1|h)，其中hi的取值就是yi的值。

ii）然后按照均匀分布产生一个0到1之间的随机浮点数，如果它小于p(vj=1|h)，vj的取值就是1，否则就是0。


对于（ii）的说明：不说别的——比如吧，你现在出去逛街，走到一个岔路口，你只想随便逛逛，所以你是有0.5的概率往左边的路，0.5的概率往右边的路；但是你不知道怎么选择哪个路，所以你选择了抛硬币，正面朝上你就向左，反面朝上就向右。现在你只抛一次，发现他是正面朝上的，你就向左走了。

——回到上面的问题，某节点A取值为1的概率是0.6（假如），也可以看做一个找不均匀的硬币，正面朝上的概率是0.6，反面朝上的概率是0.4；现在要给节点A取值，就拿这个硬币抛一下，正面朝上就取值1，反面朝上就取值0，这个就相当于抛硬币决定走哪个路的那个过程。

——现在假如找不到这样的不均匀的硬币，就拿随机数生成器来代替（生成的数是0-1之间的浮点数）；因为随机数生成器取值小于0.6的概率也是0.6，大于0.6的概率是0.4。


 RBM的用途
RBM的用途主要是两种，一是对数据进行编码，然后交给监督学习方法去进行分类或回归，二是得到了权重矩阵和偏移量，供BP神经网络初始化训练。

第一种可以说是把它当做一个降维的方法来使用。

第二种就用途比较奇怪。其中的原因就是神经网络也是要训练一个权重矩阵和偏移量，但是如果直接用BP神经网络，初始值选得不好的话，往往会陷入局部极小值。根据实际应用结果表明，直接把RBM训练得到的权重矩阵和偏移量作为BP神经网络初始值，得到的结果会非常地好。

这就类似爬山，如果一个风景点里面有很多个山峰，如果让你随便选个山就爬，希望你能爬上最高那个山的山顶，但是你的精力是有限的，只能爬一座山，而你也不知道哪座山最高，这样，你就很容易爬到一座不是最高的山上。但是，如果用直升机把你送到最高的那个山上的靠近山顶处，那你就能很容易地爬上最高的那座山。这个时候，RBM就的角色就是那个直升机。

其实还有两种用途的，下面说说。

第三种，RBM可以估计联合概率p(v,h)，如果把v当做训练样本，h当成类别标签（隐藏节点只有一个的情况，能得到一个隐藏节点取值为1的概率），就可以利用利用贝叶斯公式求p(h|v)，然后就可以进行分类，类似朴素贝叶斯、LDA、HMM。说得专业点，RBM可以作为一个生成模型（Generative model）使用。

第四种，RBM可以直接计算条件概率p(h|v)，如果把v当做训练样本，h当成类别标签（隐藏节点只有一个的情况，能得到一个隐藏节点取值为1的概率），RBM就可以用来进行分类。说得专业点，RBM可以作为一个判别模型（Discriminative model）使用。

###### 1.2限制波尔滋曼机（RBM）能量模型
* 定义
 
在说RBM之前，先来说点其他的，就是能量模型。

能量模型是个什么样的东西呢？直观上的理解就是，把一个表面粗糙又不太圆的小球，放到一个表面也比较粗糙的碗里，就随便往里面一扔，看看小球停在碗的哪个地方。一般来说停在碗底的可能性比较大，停在靠近碗底的其他地方也可能，甚至运气好还会停在碗口附近（这个碗是比较浅的一个碗）；能量模型把小球停在哪个地方定义为一种状态，每种状态都对应着一个能量，这个能量由能量函数来定义，小球处在某种状态的概率（如停在碗底的概率跟停在碗口的概率当然不一样）可以通过这种状态下小球具有的能量来定义（换个说法，如小球停在了碗口附近，这是一种状态，这个状态对应着一个能量E，而发生“小球停在碗口附近”这种状态的概率p，可以用E来表示，表示成p=f(E)，其中f是能量函数），这就是我认为的能量模型。

这样，就有了能量函数，概率之类的东西。

波尔兹曼网络是一种随机网络。描述一个随机网络，总结起来主要有两点。

第一，概率分布函数。由于网络节点的取值状态是随机的，从贝叶斯网的观点来看，要描述整个网络，需要用三种概率分布来描述系统。即联合概率分布，边缘概率分布和条件概率分布。要搞清楚这三种不同的概率分布,是理解随机网络的关键,这里向大家推荐的书籍是张连文所著的《贝叶斯网引论》。很多文献上说受限波尔兹曼是一个无向图，从贝叶斯网的观点看，受限波尔兹曼网络也可以看作一个双向的有向图，即从输入层节点可以计算隐层节点取某一种状态值的概率，反之亦然。

第二，能量函数。随机神经网络是根植于统计力学的。受统计力学中能量泛函的启发，引入了能量函数。能量函数是描述整个系统状态的一种测度。系统越有序或者概率分布越集中，系统的能量越小。反之，系统越无序或者概率分布越趋于均匀分布，则系统的能量越大。能量函数的最小值，对应于系统的最稳定状态。

* 能量函数的作用
 
为什么要弄这个能量模型呢？原因有几个。

第一、RBM网络是一种无监督学习的方法，**无监督学习的目的是最大可能的拟合输入数据**，所以学习RBM网络的目的是让RBM网络最大可能地拟合输入数据。

第二、对于一组输入数据来说，现在还不知道它符合那个分布，那是非常难学的。例如，知道它符合高斯分布，那就可以写出似然函数，然后求解，就能求出这个是一个什么样个高斯分布；但是要是不知道它符合一个什么分布，那可是连似然函数都没法写的，问题都没有，根本就无从下手。
好在天无绝人之路——**统计力学的结论表明，任何概率分布都可以转变成基于能量的模型，而且很多的分布都可以利用能量模型的特有的性质和学习过程，有些甚至从能量模型中找到了通用的学习方法。有这样一个好东西，当然要用了**。

第三、在马尔科夫随机场（MRF）中能量模型主要扮演着两个作用：一、**全局解的度量（目标函数）；二、能量最小时的解（各种变量对应的配置）为目标解**。也就是能量模型能为无监督学习方法提供两个东西：a）**目标函数**；b）**目标解**。

换句话说，就是——使用能量模型使得学习一个数据的分布变得容易可行了。

能否把最优解嵌入到能量函数中至关重要，决定着我们具体问题求解的好坏。**统计模式识别主要工作之一就是捕获变量之间的相关性**，同样**能量模型也要捕获变量之间的相关性，变量之间的相关程度决定了能量的高低**。把**变量的相关关系用图表示出来，并引入概率测度方式就构成了概率图模型的能量模型**。

**RBM作为一种概率图模型，引入了概率就可以使用采样技术求解**，在CD（contrastive divergence）算法中采样部分扮演着模拟求解梯度的角色。

能量模型需要一个定义能量函数，RBM的能量函数的定义如下

$${\rm{E}}\left( {{\rm{v}},{\rm{h}}} \right) = - \sum \limits_{i = 1}^n \sum \limits_{j = 1}^m {w_{ij}}{h_i}{v_j} - \sum \limits_{j = 1}^m {b_j}{v_j} - \sum \limits_{i = 1}^n {c_i}{h_i}$$

这个能量函数的意思就是，每个可视节点和隐藏节点之间的连接结构都有一个能量，通俗来说就是可视节点的每一组取值和隐藏节点的每一组取值都有一个能量，如果可视节点的一组取值（也就是一个训练样本的值）为(1,0,1,0,1,0)，隐藏节点的一组取值（也就是这个训练样本编码后的值）为(1,0,1)，然后分别代入上面的公式，就能得到这个连接结构之间的能量。

能量函数的意义是有一个解释的，叫做专家乘积系统（POE，product of expert），这个理论也是hinton发明的，他把每个隐藏节点看做一个“专家”，每个“专家”都能对可视节点的状态分布产生影响，可能单个“专家”对可视节点的状态分布不够强，但是所有的“专家”的观察结果连乘起来就够强了。具体我也看不太懂，各位有兴趣看hinton的论文吧，中文的也有，叫《专家乘积系统的原理及应用，孙征，李宁》。

另外的一个问题是：为什么要搞概率呢？下面就是解释。

能量模型需要两个东西，一个是能量函数，另一个是概率，有了概率才能跟要求解的问题联合起来。

下面就介绍从能量模型到概率吧。


######1.3 从能量模型到概率
1.3.1 从能量函数到概率

为了引入概率，需要定义概率分布。根据能量模型，有了能量函数，就可以定义一个可视节点和隐藏节点的联合概率

$${\rm{p}}\left( {{\rm{v}},{\rm{h}}} \right) = \frac{{{e^{ - E\left( {v,h} \right)}}}}{{ \sum \nolimits_{v,h} {e^{ - E\left( {v,h} \right)}}}}$$

也就是一个可视节点的一组取值（一个状态）和一个隐藏节点的一组取值（一个状态）发生的概率p(v,h)是由能量函数来定义的。

这个概率不是随便定义的，而是有统计热力学的解释的——在统计热力学上，当系统和它周围的环境处于热平衡时，一个基本的结果是状态i发生的概率如下面的公式

$${{\rm{p}}_i} = \frac{1}{Z} \times {e^{ - \frac{{{E_i}}}{{{k_b} \times T}}}}$$

其中表示系统在状态i时的能量，T为开尔文绝对温度，为Boltzmann常数，Z为与状态无关的常数。

我们这里的变成了E(v,h)，因为(v,h)也是一个状态，其他的参数T和由于跟求解无关，就都设置为1了，Z就是我们上面联合概率分布的分母，这个分母是为了让我们的概率的和为1，这样才能保证p(v,h)是一个概率。

现在我们得到了一个概率，其实也得到了一个分布，其实这个分布还有一个好听点的名字，可以叫做Gibbs分布，当然不是一个标准的Gibbs分布，而是一个特殊的Gibbs分布，这个分布是有一组参数的，就是能量函数的那几个参数w，b，c。

有了这个联合概率，就可以得到一些条件概率，是用积分去掉一些不想要的量得到的。

![][2]

1.3.2 从概率到极大似然
面得到了一个样本和其对应编码的联合概率，也就是得到了RBM网络的Gibbs分布的概率密度函数，引入能量模型的目的是为了方便求解的。
现在回到求解的目标——让RBM网络的表示Gibbs分布最大可能的拟合输入数据。
其实求解的目标也可以认为是让RBM网络表示的Gibbs分布与输入样本的分布尽可能地接近。
现在看看“最大可能的拟合输入数据”这怎么定义。
假设Ω表示样本空间，q是输入样本的分布，即q(x)表示训练样本x的概率， q其实就是要拟合的那个样本表示分布的概率；再假设p是RBM网络表示的Gibbs分布的边缘分布（只跟可视节点有关，隐藏节点是通过积分去掉了，可以理解为可视节点的各个状态的分布），输入样本的集合是S，那现在就可以定义样本表示的分布和RBM网络表示的边缘分布的KL距离

![][3]

如果输入样本表示的分布与RBM表示的Gibbs分布完全符合，这个KL距离就是0，否则就是一个大于0的数。

第一项其实就是输入样本的熵（熵的定义），输入样本定了熵就定了；第二项没法直接求，但是如果用蒙特卡罗抽样（后面有章节会介绍），让抽中的样本是输入样本（输入样本肯定符合分布q(x)），第二项可以用$\frac{1}{l} \sum \limits_{x \in S} {\rm{ln}}p\left( x \right)$来估计，其中的l表示训练样本个数。由于KL的值肯定是不小于0，所以第一项肯定不小于第二项，让第二项取得最大值，就能让KL距离最小；最后，还可以发现，最大化$\frac{1}{l} \sum \limits_{x \in S} {\rm{ln}}p\left( x \right)，$相当于最大化 $\sum \limits_{x \in S} {\rm{ln}}p\left( x \right)$，而这就是极大似然估计。

结论就是求解输入样本的极大似然，就能让RBM网络表示的Gibbs分布和样本本身表示的分布最接近。

这就是为什么RBM问题最终可以转化为极大似然来求解。

既然要用极大似然来求解，这个当然是有意义的——当RBM网络训练完成后，如果让这个RBM网络随机发生若干次状态（当然一个状态是由(v,h)组成的），这若干次状态中，可视节点部分（就是v）出现训练样本的概率要最大。

这样就保证了，在反编码（从隐藏节点到可视节点的编码过程）过程中，能使训练样本出现的概率最大，也就是使得反编码的误差尽最大的可能最小。

例如一个样本(1,0,1,0,1)编码到(0,1,1)，那么，(0,1,1)从隐藏节点反编码到可视节点的时候也要大概率地编码到(1,0,1,0,1)。

到这，能量模型到极大似然的关系说清楚了，，可能有点不太对，大家看到有什么不对的提一下，我把它改了。

之前想过用似然函数最大的时候，RBM网络的能量最小这种思路去解释，结果看了很多的资料，都实在没有办法把那两个极值联系起来。这个冤枉路走了好久，希望大家在学习的时候多注意，尽量避免走这个路。

下面就说怎么求解了。求解的意思就是求RBM网络里面的几个参数w，b，c的值，这个就是解，而似然函数（对数似然函数）是目标函数。最优化问题里面的最优解和目标函数的关系大家务必先弄清楚。

######1.4 求解极大似然
既然是求解极大似然，就要对似然函数求最大值，

求解的过程就是对参数就导，然后用梯度上升法不断地把目标函数提升，最终到达停机条件（在这里看不懂的同学就去看参考文献中的《从极大似然到EM》），

设参数为（注意是参数是一组参数），则似然函数可以写为：

$$ {\rm{L}}\left( {\rm{\theta }} \right) = \prod \limits_v {\rm{L}}\left( {{\rm{v|\theta }}} \right) = \prod \limits_v p\left( v \right) $$

为了省事L(v│θ)=p(v|θ)写成p(v)了,然后就可以对它的对数进行求导了（因为直接求一个连乘的导数太复杂，所以变成对数来求）

![][4]

可以看到，是对每个p(v)求导后再加和，然后就有了下面的推导了。

![][5]

到了这一步的时候，我们又可以发现问题了。我们可以看到的是，对每一个样本，第二个等号后面的两项其实都像是在求一个期望，第一项求的是 $- \frac{{\partial {\rm{E}}\left( {{\rm{v}},{\rm{h}}} \right)}}{{\partial \theta }} $这个函数在概率p(h|v)下的期望，第二项求的是 $- \frac{{\partial {\rm{E}}\left( {{\rm{v}},{\rm{h}}} \right)}}{{\partial \theta }} $这个函数在概率p(v,h)下面的期望。
还有论文是这么解释的，上面的公式，对w求偏导，还可以再进一步转化。

![][6]

到了这一步的时候，我们又可以发现问题了。我们可以看到的是，对每一个样本，第二个等号后面的两项其实都像是在求一个期望，第一项求的是 $- \frac{{\partial {\rm{E}}\left( {{\rm{v}},{\rm{h}}} \right)}}{{\partial \theta }}$这个函数在概率p(h|v)下的期望，第二项求的是$ - \frac{{\partial {\rm{E}}\left( {{\rm{v}},{\rm{h}}} \right)}}{{\partial \theta }} $这个函数在概率p(v,h)下面的期望。
还有论文是这么解释的，上面的公式，对w求偏导，还可以再进一步转化

![][7]

注意：从第二个“=”号到第三个“=”号的时候，第二个“=”号的方括号里面的第一项是把蒙特卡罗抽样的用法反过来了，从抽样回到了积分，所以得到了一个期望；第二项就是因为对每个训练样本，第二项的值算出来都一样，所以累加以后的结果除以l，相当于没有变化，还是那个期望，只是表达的形式换了。

这样的话，这个梯度还可以这么理解，第一项等于输入样本数据的自由能量函数偏导在样本本身的那个分布下的期望值（q(v,h)=p(h|v)q(v)，q表示输入样本和他们对应的隐藏增状态表示的分布），而第二项是自由能量函数的偏导在RBM网络表示的Gibbs分布下的期望值。

第一项是可以求的，因为训练样本有了，也就是使用蒙特卡罗估算期望的时候需要的样本已经抽好了，只要求个均值就可以了。

第二项也是可以求的，但是要对v和h的组合的所有可能的取值都遍历一趟，这就可能没法算了；想偷懒的话，悲剧就在于，现在是没有RBM网络表示的Gibbs分布下的样本的（当然后面会介绍这些怎么抽）。

为了进行下面的讨论，把这个梯度再进一步化简，看看能得到什么。根据能量函数的公式，是有三个参数的w，b和c，就分别对这三个参数求导

![][8]

到了这一步，来分析一下，从上面的联合概率那一堆，我们可以得到下面的

![][9]

要求第二项，就要遍历所有可能的v的值，然后根据公式去计算几个梯度的值，那样够麻烦的了，还好蒙特卡罗给出了一个偷懒的方法，见后面的章。

只要抽取一堆样本，这些样本符合RBM网络表示的Gibbs分布的（也就是符合参数确定的Gibbs分布p(x)的），就可以把上面的三个偏导数估算出来。

对于上面的情况，是这么处理的，对每个训练样本x，都用某种抽样方法抽取一个它对应的符合RBM网络表示的Gibbs分布的样本（对应的意思就是符合参数确定的Gibbs分布p(x)的），假如叫y；那么，对于整个的训练集{x1,x2,…xl}来说，就得到了一组符合RBM网络表示的Gibbs分布的样本{y1,y2,…,yl}，然后拿这组样本去估算第二项，那么梯度就可以用下面的公式来近似了.

![][10]

其中xk表示第k个训练样本，yk表示第k个训练样本对应的RBM网络表示的Gibbs分布（不妨将这个分布称为R）的样本（yk是根据分布R抽取的样本，而且这个样本是从xk出发，用Gibbs抽样抽取出来的，也就是说yk服从分布R，可以用来估算第二项，同时yk跟xk有关），Vyk表示可视节点取值为yk的时候的状态，那么Vykj就表示yk的第j个特征的取值。

这样，梯度出来了，这个极大似然问题可以解了，最终经过若干论迭代，就能得到那几个参数w，b，c的解。

式子中的v是指{x1,x2,…xl}中的一个样本，因为$\frac{{\partial {\rm{lnL}}({\rm{\theta }}|{\rm{v}})}}{{\partial \theta }} = \sum \limits_v \frac{{\partial {\rm{ln}}p\left( v \right)}}{{\partial \theta }}$，对样本进行累加时，第一项是对所有样本进行累加，而第二项都是一样的（是一个积分的结果，与被积变量无关，是一个标量），所以累加后1/l就没有了，只有对l项y进行累加，到了下面CD-k算法的时候，每次只对一个x和一个y进行处理，最外层对x做L次循环后得到的累加结果是一样的.
上面提到的“某种抽样方法”，现在一般就用Gibbs抽样，然后hinton教授还根据这个弄出了一个CD-k算法，就是用来解决RBM的抽样的。下面一章就介绍这个吧。

######1.5 用到的抽样方法
一般来说，在hinton教授还没弄出CD-k之前，解决RBM的抽样问题是用Gibbs抽样的。

Gibbs抽样是一种基于马尔科夫蒙特卡罗（Markov Chain Monte Carlo,MCMC）策略的抽样方法。具体就是，对于一个d维的随机向量x=(x1,x2,…xd)，假设我们无法求得x的联合概率分布p(x)，但我们知道给定x的其他分量是，其第i个分量xi的条件分布，即p(xi|xi-),xi-=(x1,x2,…xi-1,xi+1…xd)。那么，我们可以从x的一个任意状态（如(x1(0),x2(0),…,xd(0))）开始，利用条件分布p(xi|xi-)，迭代地对这状态的每个分量进行抽样，随着抽样次数n的增加，随机变量(x1(n),x2(n),…,xd(n))的概率分布将以n的几何级数的速度收敛与x的联合概率分布p(v)。

Gibbs抽样其实就是可以让我们可以在位置联合概率分布p(v)的情况下对其进行抽样。

基于RBM模型的对称结构，以及其中节点的条件独立行，我们可以使用Gibbs抽样方法得到服从RBM定义的分布的随机样本。在RBM中进行k步Gibbs抽样的具体算法为：用一个训练样本（或者可视节点的一个随机初始状态）初始化可视节点的状态v0，交替进行下面的抽样：

![][11]

在抽样步数n足够大的情况下，就可以得到RBM所定义的分布的样本（即符合参数确定的Gibbs分布的样本）了，得到这些样本我们就可以拿去计算梯度的第二项了。

可以看到，上面进行了k步的抽样，这个k一般还要比较大，所以是比较费时间的，尤其是在训练样本的特征数比较多（可视节点数大）的时候，所以hinton教授就弄一个简化的版本，叫做CD-k，也就对比散度。

对比散度是英文ContrastiveDivergence（CD）的中文翻译。与Gibbs抽样不同，hinton教授指出当使用训练样本初始化v0的时候，仅需要较少的抽样步数（一般就一步）就可以得到足够好的近似了。

在CD算法一开始，可见单元的状态就被设置为一个训练样本，并用上面的几个条件概率来对隐藏节点的每个单元都从{0,1}中抽取到相应的值，然后再利用 来对可视节点的每个单元都从{0,1}中抽取相应的值，这样就得到了v1了，一般v1就够了，就可以拿来估算梯度了。

下面给出RBM的基于CD-k的快速学习的主要步骤。

![][12]

其中，之所以第二项没有了那个1/l，就是因为这个梯度会对所有样本进行累加（极大似然是所有训练样本的梯度的和），最终加和的结果跟现在这样算是相等的（刚好是l个样本，l个第二项相加后，最终结果刚好等于每一个第二项的那个累加符号后面的那一项，而这里所有结果加和后，也能得到相同的值）。

###### 1.6 马尔科夫蒙特卡罗简介
下面简介一下马尔科夫蒙特卡罗（MCMC）方法。

最早的蒙特卡罗方法，是由物理学家发明的，旨在于通过随机化的方法计算积分。假设给定函数h(x)，我们想计算积分 $\smallint \limits_{\rm{a}}^b h\left( x \right)dx$，但是又没有办法对区间内的所有x的取值都算一遍，我们可以将h(x)分解为某个函数f(x)和一个定义在(a, b)上的概率密度函数p(x)的乘积。这样整个积分就可以写成：
$\smallint \limits_{\rm{a}}^b h\left( x \right)dx = \smallint \limits_a^b f\left( x \right)p\left( x \right)dx = {E_{p\left( x \right)}}\left[ {f\left( x \right)} \right]$

这样一来，原积分就等同于f(x)在p(x)这个分布上的均值(期望)。这时，如果我们从分布p(x)上采集大量的样本x1, x2, ..., xn，这些样本符合分布p(x)，即$\forall {\rm{i}},{x_i}/ \sum \limits_i {x_i} \approx p\left( {{x_i}} \right)$，那么，我们就可以通过这些样本来逼近这个均值：
$$\smallint \limits_a^{\rm{b}} h\left( x \right)dx = {E_{p\left( x \right)}}\left[ {f\left( x \right)} \right] = \frac{1}{n} \sum \limits_{i = 1}^n f\left( {{x_i}} \right)$$
这就是蒙特卡罗方法的基本思想。
然后剩下的就是怎么样能够采样到符合分布p(x)的样本了，这个简单来说就是一个随机的初始样本，通过马尔科夫链进行多次转移，最终就能得到符合分布p(x)的样本。上面介绍的Gibbs是一种比较常用的抽样算法。
有关Gibbs抽样的相关内容可以参看文献【12】。
这就是蒙特卡罗方法的基本思想。

然后剩下的就是怎么样能够采样到符合分布p(x)的样本了，这个简单来说就是一个随机的初始样本，通过马尔科夫链进行多次转移，最终就能得到符合分布p(x)的样本。上面介绍的Gibbs是一种比较常用的抽样算法。

有关Gibbs抽样的相关内容可以参看文献【12】。


##### 果皮提的推到式
[传送][15]

##### 含有自由能量函数定义的讲解
[传送][13]

##### RBM（限制玻尔兹曼机）、DBN（深度信念网络）介绍 
[传送][14]
 
##### CRF代码资源
[传送][16]

[CRF原理 介绍][20]

[一个有实现的机器学习和深度学习博客][17]

##### 矩阵的范数求导
[传送][18]

##### 准确律召回率
[传送][19]

[1]:http://img.blog.csdn.net/20130628222803078?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbXl0ZXN0bXk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center
[2]:http://img.blog.csdn.net/20140302151537296
[3]:http://img.blog.csdn.net/20140302151223562
[4]:http://img.blog.csdn.net/20140424184717906
[5]:http://img.blog.csdn.net/20140302151743062
[6]:http://img.blog.csdn.net/20140302152015953
[7]:http://img.blog.csdn.net/20140302152015953
[8]:http://img.blog.csdn.net/20140302152109750
[9]:http://img.blog.csdn.net/20140302152329531
[10]:http://img.blog.csdn.net/20140302152451796
[11]:http://img.blog.csdn.net/20140302152658812
[12]:http://img.blog.csdn.net/20140302152723390
[13]:http://blog.csdn.net/chlele0105/article/details/17309491
[14]:http://blog.csdn.net/chlele0105/article/details/17251971
[15]:http://blog.csdn.net/itplus/article/details/19168989
[16]:http://blog.csdn.net/itplus/article/details/19168989
[17]:http://blog.csdn.net/chlele0105/article/category/1408946/3
[18]:http://blog.csdn.net/chlele0105/article/details/21081917
[19]:http://blog.csdn.net/chlele0105/article/details/21325895
[20]:http://blog.csdn.net/chlele0105/article/details/14897761






