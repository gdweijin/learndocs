####最长公共子串、最长公共子序列的java实现与NLP应用

#####使用场景
   以前HanLP使用“最短编辑距离”来做推荐器，有大提高，主要的缺点是根据拼音序列的编辑距离做推荐的时候，交错很常见，而编辑距离却不那么大。这时作者就在寻求一种补充的评分算法，去评判两个句子在拼音这一纬度上的相似程度。
   作者决定导入最长公共子串和最长公共子序列作为补充。
   
#####两者之间的区别
最长公共子串 （Longest Common Substring）指的是两个字符串中的最长公共子串，要求子串一定连续。
最长公共子序列（Longest Common Subsequence）指的是两个字符串中的最长公共子串，不要求子串连续。

#####求解
两者的求解与编辑距离一样，都是动态规划，用空间换时间

设串A长度la，设串B长度lb，定义dp[i][j] = t (0 <= i < la,0<=j<lb,当A[i]= B[j]的时候t是1，否则是0)。那么对角线上连续的1就是代表着一个公共子串，取其中最长的就是了。

举个例子，对于 "bab" 和 "caba"来讲，dp数组如下表示：
![](http://ww2.sinaimg.cn/large/6cbb8645jw1em2ct4jd9kj2041042web.jpg)

要统计对角线的长度的话，在实现上有些麻烦，不如采取一个策略，将dp定义稍作修改，当A[i] = B[j]的，让dp[i][j]=dp[i-1][j-1] + 1，于是就可以省略一维数组：
![](http://ww2.sinaimg.cn/large/6cbb8645jw1em2cwm0itcj203q03r3yc.jpg)
对角线的长度就是上图对角线连续部分最后一个元素了。于是我们只要一个数组就可以代替上述矩阵，定义 new_dp[i]=第i条对角线的长度，又由于对角线是对称的，所以这个数组的长度只要取la和lb中最长的那个就可以了。这样空间复杂度是O（n）
递推关系如下：
![](http://ww1.sinaimg.cn/large/6cbb8645jw1em2dhxrdnkj20h50dvq7v.jpg)

举一个复杂一点的例子
A=www.hanks.com
b=hanks
![](http://ww4.sinaimg.cn/large/6cbb8645jw1em2d8efbhfj209y04i74n.jpg)
在存储上，只需要一维数组记录一行，然后递推下一行即可：
![]()

#####还可以继续优化么？
当然可以，注意到递推关系 dp[i][j] = dp[i-1][j-1] + 1,每个元素只需要知道它的左上角的值就行而左上角又取决于左上角的左上角......所以可以一次顺着一条对角线算完一条对角线，然后计算右上或左下（取决于la和lb哪个长）的那条对角线就行了，这样空间的复杂度是O（1）,常数复杂度！
递推关系是这样的感觉：
![](http://ww3.sinaimg.cn/large/6cbb8645jw1em2dii0g0rj20h40dvn29.jpg)

































